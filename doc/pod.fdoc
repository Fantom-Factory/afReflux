
One the things that originally enticed me to Fantom was FWT. I already had a soft spot for SWT because it was far simpler than Swing, and Fantom's FWT wrapper simplified SWT even further, exponentially so!

I also really liked the idea of 'flux', creating applications based on a browser paradigm and the ability to represent database entities with URIs. Complete with 'Views' and 'SideBars' it looked like it was inspired by Eclipse's RCP. In all, it was really neat!

Thanks Andy! Thanks Brian!

Only I kept finding the 'flux' implementation a bit, um, *clunky*. It was hard to customise, configuration by index props seemed like a poor man's IoC, and installing an app on a fresh Fantom install required lots of annoying manual config file changes. I found myself forever adding pathces to make flux behave as I wanted it to.

So, wishing to make life easy for myself and, fuelled by a desire to create a customisable voice driven explorer application, I tinkered with a new code base that's now evolved to 'Reflux'. It doesn't quite have all the features flux has, but I think it has enough to be getting on with...



Overview [#overview]
********************
'Reflux' is a framework for creating simple FWT desktop applications. 

Modelled after an internet browser, Reflux lets you explore and edit resources via URIs. It expands upon Fantom's FWT by adding:
 
 - **An IoC container** - Reflux applications are IoC applications.
 - **Events** - An application wide eventing mechanism. 
 - **Customisation** - All aspects of a Reflux application may be customised.
 - **Context sensitive commands** - Global cmds may be enabled / disabled. 
 - **Browser session** - A consistent means to store session data.
 - **New FWT widgets** - Fancy tabs and a working web browser.
 
Reflux was inspired by Fantom's core 'flux' library.

> Reflux :: Flux -> Reloaded.



Install [#install]
******************
Install '@{project.name}' with the Fantom Repository Manager ( [fanr]`docFanr::Tool.install` ):

  C:\> fanr install -r http://repo.status302.com/fanr/ @{pod.name}

To use in a [Fantom]`http://fantom.org/` project, add a dependency to 'build.fan':

  depends = ["sys 1.0", ..., "@{pod.name} @{pod.version}"]



Documentation [#documentation]
******************************
Full API & fandocs are available on the [Status302 repository]`http://repo.status302.com/doc/@{pod.name}/`.




Quick Start [#quickStart]
*************************



Usage [#usage]
**************
'Reflux' takes the internet browser strategy of labelling everything with a URI. Be it a file, an internet resource, or a database entity - if it can be identified by a URI then it may presented and edited in Reflux.

A Reflux application is made up of:

 - Menu bar
 - Tool bar
 - Global commands
 - Panels
 - Views

![Screenshot of the Alien-Factory Explorer application]`afReflux.afExplorer.png`

URIs are typed into the address bar. The typed URI is then resolved to a 'Resource'. Resource objects hold meta data that describe how it should be displayed / interacted with. Views are used to view and / or edit resources. Panels are extra tabs that show arbitrary data; for example, the `ErrorsPanel` lists any errors incurred by the application. 

The menu and tool bars are customisable via IoC contributions. Global commands wrap standard FWT commands to make them context sensitive; for example, the Save global command is only enabled when the current view is dirty.

Note that Reflux itself is just a toolkit. See the [Alien-Factory Explorer]`pod:afExplorer` application for a concrete example of Reflux use.



Panels [#Panels]
****************
[Panels]`Panel` are widget panes that decorate the edges of the main window. Only one instance of each panel type may exist. They are typically created at application startup and live until the application shuts down.

To create a custom panel, first create a class that extends `Panel`. Panels must set the 'content' field in order to display anything. This example just sets its FWT content to a yellow label: 

pre>
class MyPanel : Panel {
    new make(|This| in) : super(in) { 
        content = Label() {
            it.text = "Hello Mum!"
            it.bg   = Color.yellow
        }
    }
}
<pre

Note that the Panel's ctor must take an 'it-block' parameter and pass it up to the superclass to be executed. This is so IoC can inject all those lovely dependencies. Now contribute an instance of the panel to the 'Panels' service in your 'AppModule':

pre>
class AppModule {
    @Contribute { serviceType=Panels# }
    static Void contributePanels(Configuration config) {
        myPanel := config.autobuild(MyPanel#)
        config.add(myPanel)
    }
}
<pre

Panels need to be *autobuilt* so IoC injects all the dependencies (via that it-block ctor parameter). 

Panels are automatically added to the 'View -> Panels' menu. If the panel does not set a name it defaults the Panel's type, minus any 'Panel' suffix. When displayed, our simple panel should look like:

![Screenshot of Panel Example]`afReflux.panelExample.png`

Note that Panels are not displayed by default; but the user's display settings are saved from one session to the next. To force the user to always start with the panel displayed, show it programmatically on application startup: 

pre>
Reflux.start("Example", [AppModule#]) |Reflux reflux, Window window| {
    reflux.showPanel(MyPanel#)
} 
<pre

Panels contain several callback methods that are invoked at different times of its lifecycle. These are:

 - 'onShow()' - called when it's added to the tab pane.
 - 'onActivate()' - called when it becomes the active tab.
 - 'onModify()' - called when panel details are modified, such as the name or icon. 
 - 'onDeactivate()' - called when some other tab becomes active.
 - 'onHide()' - called when it is removed from the tab pane.
 - 'refresh()' - called when the panel 'isShowing' and the refresh button is clicked.

Panel's are 

Panels are automatically added to the 'EventHub' - see [Eventing]`#eventing` for details.



Views [#views]
**************
[Views]`View` are 'Panels' that are associated with an (editable) resource. They are displayed in the centre of the Window.

Custom views must extends `View`, which in turn extends 'Panel'. Like panels, views must set the 'content' field to display anything. This example view just displays the resource name in a green box: 

pre>
class MyView : View {
    Label label

    new make(|This| in) : super(in) { 
        content = label = Label() {
            it.bg = Color.green
        }
    }
    
    override Void load(Resource resource) {
        super.load(resource)
        label.text = "Resource Name: ${resource.name}"
    }
}
<pre

Because a View is associated with a resource, it has a few more callbacks:

 - 'load()' - called when the view should display a resource. 
 - 'save()' - called when the save button is clicked.
 - 'refresh()' - called when the refresh button is clicked.
 - 'confirmClose()' - called when the view is being closed.

Resources decide how they want to be displayed, so to display our view we need to create a concrete Resource implementation...



Resolving URIs [#resolvingURIs]
*******************************
Lets take this simple resource object:

pre>
class MyResource : Resource {
    override Uri    uri
    override Str    name
    override Image? icon

    new make(Uri uri, |This|in) : super.make(in) { 
        this.uri  = uri
        this.name = uri.name
        this.icon = Image("fan://icons/x16/database.png")
    }

    override Type[] viewTypes() {
        [MyView#]
    }    
}
<pre

It holds it's name, has a *database* icon and the 'viewTypes()' method says it should be represented by the 'MyView' class.

Should 'viewTypes()' return more than one type, the user may cycle between them using drop down in the address bar or an 'F12' shortcut. This useful for toggling between view and edit modes.

It is the job of [UriResolvers]`UriResolver` to convert URI strings, as entered in the address bar, into resource instances. The following URI resolver will convert any URI with the scheme 'example:' into a 'MyResource' object:

pre>
class MyResolver : UriResolver {
    @Inject Registry registry
    
    new make(|This|in) { in(this) }
    
    override Resource? resolve(Str uri) {
        uri.toUri.scheme == "example"
            ? registry.autobuild(MyResource#, [uri.toUri])
            : null
    }
}
<pre

To use 'MyResolver' it must be contributed to the 'UriResolvers' service in the 'AppModule':

pre>
@Contribute { serviceType=UriResolvers# }
static Void contributeUriResolvers(Configuration config) {
    config["myResolver"] = config.autobuild(MyResolver#)
}
<pre

When 'example:foo-bar' is entered into the address bar, the following should happen:

 - 'MyResolver' resolves 'example:foo-bar' and builds a 'MyResource' instance.
 - 'MyResource' returns 'MyView' as a view type.
 - 'MyView' is created and asked to load the 'MyResource'.

And this should be displayed:

![Screenshot of View Example]`afReflux.viewExample.png`



Menu Bar [#menuBar]
*******************
Reflux comes with a pre-configured menu bar which is suitable for most applications. However it may be altered via IoC contributions. 

Each main Reflux menu is a standard FWT Menu instance, but is also configured as an IoC service and contributed to 'afReflux.menuBar'. The menus use the following service IDs: 

 - 'afReflux.fileMenu'
 - 'afReflux.editMenu'
 - 'afReflux.viewMenu'
 - 'afReflux.historyMenu'
 - 'afReflux.prefsMenu'
 - 'afReflux.helpMenu'

So, removing the history menu is as simple as:

pre>
@Contribute { serviceId="afReflux.menuBar" }
static Void contributeMenuBar(Configuration config) {
    config.remove("afReflux.historyMenu")
}
<pre

And to add your own menu:

pre>
@Contribute { serviceId="afReflux.menuBar" }
static Void contributeMenuBar(Configuration config) {
    config["example"] = Menu() { it.text = "Example"}
}
<pre

Use IoC ordering constraints to further position the menu:

pre>
@Contribute { serviceId="afReflux.menuBar" }
static Void contributeMenuBar(Configuration config) {
    menu := Menu() { it.text = "Example"}
    config
        .set("example", menu)
        .after("afReflux.editMenu")
        .before("afReflux.viewMenu")
}
<pre



Menu Items [#menuItems]
=======================
The menus services take contributions of 'MenuItems', so to add a *Hello Mum!* command to the edit menu:

pre>
@Contribute { serviceId="afReflux.editMenu" }
static Void contributeEditMenu(Configuration config) {
    command := Command("Hello Mum!", null) |Event event| { echo("Hello Mum!") }
    config["myCommand"] = MenuItem(command)
}
<pre

Note that while a standard FWT command is used above, it is recommended that 'RefluxCommands' are used so any invocation errors are routed to the 'Errors' service for standardised handling. 'GlobalCommands' may also be used.

Use IoC ordering constraints to further position any contributed commands / menu items. For example, to place the *Hello Mum!* command as the first item:

pre>
@Contribute { serviceId="afReflux.editMenu" }
static Void contributeEditMenu(Configuration config) {
    command := Command("Hello Mum!", null) |Event event| { echo("Hello Mum!") }
    config
        .set("myCommand", MenuItem(command))
        .before("afReflux.cmdUndo")
}
<pre

When ordering menu items commands consult the source code of 'RefluxModule' to find current contribution IDs, such as 'afReflux.cmdUndo' above.



Tool Bar [#toolBar]
*******************
The tool bar may be configured in much the same way as the menu bar, with IoC contributions. To add fwt 'Button' objects, contribute them to the 'afReflux.toolBar' service:

pre>
@Contribute { serviceId="afReflux.toolBar" }
static Void contributeEditMenu(Configuration config) {
    command := Command("Hello Mum!", null) |Event event| { echo("Hello Mum!") }
    config["myButton"] = Button(command)
}
<pre

To remove or position buttons in the tool bar, consult the 'RefluxModule' source code for current contribution IDs.



Global Commands [#globalCommands]
*********************************
Global commands are wrappers around standard fwt commands that may be accessed from the 'GlobalCommands' service.
They are generally added to menus and tool bars. For the accelerator (keyboard shortcuts) to work, they need to be added to a menu bar. 

Global command instances should be contributed to the 'GlobalCommands' service:

pre>
@Contribute { serviceType=GlobalCommands# }
static Void contributeGlobalCommands(Configuration config) {
    config["myGlobCmd"] = config.autobuild(MyGlobalCommand#)
}
<pre

Global commands are disabled by default. It is up to 'Views' and 'Panels' (or any service) to add enabler functions that dictate when the command should be active. This way, global commands may be decoupled from their context sensitivity. For example, to only enable 'myGlobCmd' when 'MyPanel' is active:    

pre>
class MyPanel : Panel {
    @Inject GlobalCommands globalCommands

    new make(|This| in) : super(in) { }
    
    override Void onActivate() {
        globalCommands["myGlobCmd"].addEnabler("myPanel") |->Bool| { true }
    }

    override Void onDeactivate() {
        globalCommands["myGlobCmd"].removeEnabler("myPanel")
    }
}
<pre

Other Panels may add their own enabler functions thereby allowing the command to be enabled in *multiple* situations.

Note that enabler functions are OR'ed together, that is, it only takes one function to return 'true' for the command to be enabled.



Eventing [#eventing]
********************
Reflux eventing allows different parts of the application to communicate with other parts without direct references.  



Define [#eventDefine]
=====================
Reflux events are defined by a 'mixin'. The mixin should define *virtual* (or *abstract*) methods, these are the *events*. As such, it is convention that they are named 'onXXXX()':

pre>
mixin MyEvents {
    virtual Void onMyEvent(Str stuff) { }
    
    ...
}
<pre

Note that event methods should not return anything (they're strictly fire and forget) and any *virtual* implementations should do nothing. 
 
For 'MyEvents' to be recognised as an event type it needs to be contributed to the 'EventTypes' service:

pre>
@Contribute { serviceType=EventTypes# }
static Void contributeEventHub(Configuration config) {
    config.add(MyEvents#)
}
<pre



Fire [#eventFire]
=================
Reflux creates a instance of the event mixin that can be injected into your components and services. To fire an event, just call the method. 

pre>
class MyService {
    @Inject MyEvents myEvents
    
    new make(|This|in) { in(this) }
    
    Void someHandler() {
        myEvents.onMyEvent("wotever")
    }
}
<pre



Handle [#eventHandle]
=======================
Multiple classes may handle events. For a class to so, it must first register itself with the 'EventHub' service. When an event is fired, each registered class is scanned to see if it implements the appropriate event mixin. If it does, the event method is called:  

pre>
class MyOtherService : MyEvents {
    
    new make(EventHub eventHub) {
        eventHub.register(this)
    }
    
    override Void onMyEvent(Str stuff) {
        echo("Got ${stuff}")
    }
}
<pre

Event methods may be 'abstract', but by making them 'virtual' event handler classes are not forced to implement all the event methods.

Because it is common for them to receive events, all instances of 'Panels', 'Views' and 'GlobalCommands' are automatically added to 'EventHub' by default. Therefore to receive events, all they need to do is implement the event mixin. 



Example Code [#exampleCode]
***************************
Following is a basic Reflux app that incorporates the ideas and example code shown in previous sections. When learning Reflux, it is suggested that you start here and then look at the source code of the [Explorer]`pod:afExplorer` application.


